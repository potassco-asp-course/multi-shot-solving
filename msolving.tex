%------------------------------------------------------------
\lecture{Multi-shot ASP Solving}{msolving}
%------------------------------------------------------------
\part{Multi-shot ASP Solving}
%------------------------------------------------------------
%\newcommand{\PRG}{\ensuremath{P}}
\newcommand{\QRG}{\ensuremath{Q}}
\newcommand{\RRG}{\ensuremath{R}}
%------------------------------------------------------------
\section{Motivation}
%------------------------------------------------------------
\input{msolving/motivation}
% ----------------------------------------------------------------------
\begin{frame}[c]{Clingo \ = \ ASP + Control}
  \begin{itemize}
  \item<2-> \structure{ASP}
    \begin{itemize}
    \item<2-> \texttt{\#program <name> [ (<parameters>) ]}
      \begin{itemize}
      \item<3-> \structure{Example}   \texttt{\#program play(t).}
%      \item \structure{Default}\, \ \texttt{\#program base.}
      \end{itemize}
    \item <2->\texttt{\#external <atom> [ : <body> ]}
      \begin{itemize}
      \item<3-> \structure{Example} \texttt{\#external mark(X,Y,P,t)\;:\;field(X,Y),\;player(P).}
      \end{itemize}
    \end{itemize}
    \medskip
  \item<4-> \structure{Control}
    \begin{itemize}
    % \item<4-> Lua \ (\texttt{www.lua.org})
    %   \begin{itemize}
    %   \item<5-> \structure{Example} \texttt{prg:solve(), prg:ground(parts), \dots}
    %   \end{itemize}
    \item<4-> Python \ (\texttt{www.python.org})
      \begin{itemize}
      \item<5-> \structure{Example} \texttt{prg.solve(), prg.ground(parts), \dots}
      \end{itemize}
    \item <6-> C, Lua, and Prolog embeddings are available too
    \end{itemize}
    \medskip
    \item<7-> \structure{Integration}
      \begin{itemize}
      \item <7-> in ASP: embedded scripting language \ (\texttt{\#script})
      \item <7-> in Python: library import \ (\texttt{import clingo})
      \end{itemize}
  \end{itemize}
\end{frame}
% ----------------------------------------------------------------------
\begin{frame}[fragile,c]{Vanilla \textit{clingo}}
  \pause
  \begin{center}
    \begin{minipage}{0.5\linewidth}
\begin{semiverbatim}
\alert<2>{#script} (python)
def \alert<3>{main}(prg):
    parts = []
    parts.append(("base", []))
    prg.\alert<3>{ground}(parts)
    prg.\alert<3>{solve}()
\alert<2>{#end}.
\end{semiverbatim}
    \end{minipage}
  \end{center}
\end{frame}
% ----------------------------------------------------------------------
\begin{frame}[fragile,c]{Hello world!}

\begin{center}
\begin{minipage}{0.5\linewidth}
\begin{semiverbatim}
{\bf{}#script} (python)
def \alert<3>{main}(prg):
    print("Hello world!")
{\bf{}#end}.
\end{semiverbatim}
\end{minipage}

\bigskip\pause\bigskip

\begin{minipage}{0.95\linewidth}\footnotesize
\begin{semiverbatim}
$ clingo hello.lp\pause
clingo version 4.5.0
Reading from hello.lp
\alert<4>{Hello world!}
UNKNOWN

Models       : 0+
Calls        : 1
Time         : 0.009s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.000s
\end{semiverbatim}
\end{minipage}
\end{center}
\end{frame}
% ----------------------------------------------------------------------
\begin{frame}[fragile,c]{Preview on incremental solving}
\begin{lstlisting}
#(\pause#)#program base.

p(0).#(\pause#)

#program step (t).

p(t) :- p(t-1).#(\pause#)

#program check (t).
#external plug(t).

:- not p(42), plug(t).
\end{lstlisting}
\end{frame}
% ------------------------------------------------------------
\section{\texttt{\#program} and \texttt{\#external} declaration}
%------------------------------------------------------------
\begin{frame}[fragile]{\texttt{\#program} declaration}
  \begin{itemize}
  \item A \alert{program declaration} is of form
    \[
    \texttt{\#program}~n\,(p_1,\dots,p_k)
    \]
    where $n,p_1,\dots,p_k$ are non-integer constants
  \item <2-> We call $n$ the \alert<2>{name} of the declaration and $p_1,\dots,p_k$ its \alert<2>{parameters}
    \smallskip
  \item <3-> \structure{Convention}
    Different occurrences of program declarations with the same name share the same parameters
    % \only<4>{(yet \clingo~4 permits others)}
    \smallskip
  \item <5-> \structure{Example} \
    \begin{minipage}[t]{0.5\linewidth}
      \begin{semiverbatim}
        #program \alert<5>{acid(k)}.
        b(k).
        c(X,k) :- a(X).
        #program \alert<5>{base}.
        a(2).
      \end{semiverbatim}
    \end{minipage}
  \end{itemize}
\end{frame}
%------------------------------------------------------------
\begin{frame}[fragile]{Scope of \texttt{\#program} declarations}
  \begin{itemize}
  \item <1->
    The \alert{scope} of an occurrence of a program declaration in a list of rules and declarations
    consists of the set of all rules and non-program declarations appearing between
    the occurrence and the next occurrence of a program declaration or the end of the list
  \item <2->
    Rules and non-program declarations outside the scope of any program declaration
    are implicitly preceded by a \alert<2>{\lstinline{base}} program declaration
    \medskip
  \item <3-> \structure{Example} \
    \begin{minipage}[t]{0.5\linewidth}
      \begin{semiverbatim}
        \alert<5>{a(1).}
        #program \alert<4>{acid(k)}.
        \alert<4>{b(k).}
        \alert<4>{c(X,k) :- a(X).}
        #program \alert<5>{base}.
        \alert<5>{a(2).}
      \end{semiverbatim}
    \end{minipage}
  \end{itemize}
\end{frame}
%------------------------------------------------------------
\begin{frame}{Scope of \texttt{\#program} declarations}
  \begin{itemize}
  \item <1->
    Given a list $\RRG$ of (non-ground) rules and declarations and a name $n$,
    we define $\RRG(n)$ as the set of all rules and non-program declarations
    in the scope of all occurrences of program declarations with name $n$
  \item <2->
    We often refer to $\RRG(n)$ as a subprogram of $\RRG$
    \medskip
  \item <3-> \structure{Example} \
    \begin{itemize}\normalsize
    \item \(
      \RRG(\texttt{base})=\{a(1),a(2)\}
      \)
      \smallskip
    \item
      \(
      \RRG(\texttt{acid})\only<5->{[k/42]}=\{b(\only<-5>{k}\only<6>{42}), c(X,\only<-5>{k}\only<6>{42})\leftarrow a(X)\}\only<5>{[k/42]}
      \)
    \end{itemize}
      \smallskip
  \item <4->
    Given a name $n$ with associated parameters $(p_1,\dots,p_k)$,
    the instantiation of $\RRG(n)$ with a term tuple $(t_1,\dots,t_k)$
    results in the set
    \[
    \RRG(n)[p_1/t_1,\dots,p_k/t_k]
    \]
    obtained by replacing in $\RRG(n)$ each occurrence of $p_i$ by $t_i$ % for $1\leq i\leq k$
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{Contextual grounding}
  \begin{itemize}
  \item <1-> Rules are grounded relative to a set of atoms, called \alert{atom base}
  \item <2->
    Given a set \RRG\ of (non-ground) rules and two sets $C,D$ of ground atoms,
    we define an instantiation of \RRG\ relative to $C$ as a ground program \cground{\RRG}{C} over $D$
    subject to the following conditions:
    \begin{align*}
      C& {}\subseteq D\subseteq C \cup\head{\cground{\RRG}{C}}
      \\
      \cground{\RRG}{C}& {} \subseteq
                         \{
                         \head{r}\leftarrow\pbody{r}\cup \{\naf{a} \mid a\in\nbody{r}\cap D\}
      \\&\qquad\qquad\qquad\qquad
          \mid
          r\in \ground{\RRG},
          \pbody{r}\subseteq D
          \}
    \end{align*}
  \item <3-> \structure{Example} Given
    \(
    R= \{\; a(X) \leftarrow f(X), e(X);\ b(X) \leftarrow f(X), \naf{e(X)} \;\}
    \)

    and
    \(
    C=\{f(1),f(2),e(1)\}
    \),
    we obtain
    \[
    \cground{R}{C}
    =
    \left\{
      \begin{array}{ll}
        a(1) \leftarrow f(1), e(1); & b(1) \leftarrow f(1), \naf{e(1)}\\
                                    & b(2) \leftarrow f(2)
      \end{array}
    \right\}
    \]
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{\texttt{\#external} declaration}
  \begin{itemize}
  \item<1-> An \alert{external declaration} is of form
    \[ % begin{equation}\label{eq:external:declaration}
      \texttt{\#external}~a : B
    \] % end{equation}
    where $a$ is an atom and $B$ a rule body
  \item <2->
    A logic program with external declarations is said to be \alert<2>{extensible}
    \medskip
  \item <3-> \structure{Example} \
    \begin{minipage}[t]{0.5\linewidth}
      \begin{semiverbatim}
        #external e(X) : f(X), X < 2.
        f(1..2).
        a(X) :- f(X), e(X).
        b(X) :- f(X), not e(X).
      \end{semiverbatim}
    \end{minipage}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Grounding extensible logic programs}
  \begin{itemize}
  \item <1->
    Given an extensible program $\RRG$,
    we define
    \begin{align*}
      \QRG & {} = \{a\leftarrow B,\varepsilon\mid({\small\textbf{\texttt{\#external}}}~a : B)\in \RRG\}\\
      \RRG'& {} = \{a\leftarrow B\in\RRG\}
    \end{align*}
  \item <2-> \structure{Note} \
    An external declaration is treated as a rule \
    \(
    a \leftarrow B,\varepsilon
    \)\\
    where $\varepsilon$ is a ground marking atom
  \item <3->
    Given an atom base $C$,
    the ground instantiation of an extensible logic program $\RRG$ is defined as
    a (ground) \alert{logic program}~$P$ \alert{with externals}~$E$
    where
    \begin{align*}
      P & {} = \{r\in\cground{\RRG'\cup \QRG}{C\cup\{\varepsilon\}} \mid \varepsilon\notin\body{r}\}\\
      E & {} = \{\head{r}\mid r\in\cground{\RRG'\cup \QRG}{C\cup\{\varepsilon\}}, \varepsilon\in\body{r}\}
    \end{align*}
  \item <4-> \structure{Note} The marking atom $\varepsilon$ appears neither in $P$ nor $E$, respectively,
    \phantom{Note} and $P$ is a logic program over $C\cup E\cup\head{P}$
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
  \begin{itemize}
  \item Extensible program
    \begin{semiverbatim}
  \only<1-2>{\only<1>{#external }e(X) :\only<2->{-} f(X), g(X)\only<2->{, \(\varepsilon\)}.}\only<3->{e(1) :- f(1), g(1), \(\varepsilon\).}\only<3-7>{   \textcolor<7>{red}{e(2)} :- f(2), \textcolor<6->{red}{g(2)}, \(\varepsilon\).}
  f(1). f(2).
  \only<1-3>{a(X) :- f(X), e(X).}\only<4->{a(1) :- f(1), e(1).}\only<4-7>{      a(2) :- f(2), \textcolor<7>{red}{e(2)}.}
  \only<1-3>{b(X) :- f(X), not e(X).}\only<4->{b(1) :- f(1), not e(1).}\only<4->{  b(2) :- f(2)\only<-7>{, not \textcolor<7>{red}{e(2)}}.}
    \end{semiverbatim}
    \vspace{-3ex}
  \item[]<5-> Atom base $\{\text{\lstinline{g(1)}}\}\cup\{\varepsilon\}$
    \medskip
  \item<9-> Ground program
    \begin{semiverbatim}
  f(1). f(2).
  a(1) :- \only<-9>{f(1), }e(1).
  b(1) :- \only<-9>{f(1), }not e(1).\only<10>{      }   b(2)\only<-9>{ :- f(2)}.
    \end{semiverbatim}
    \vspace{-3ex}
  \item[]<9-> with externals $\{\text{\lstinline{e(1)}}\}$
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\section{Module composition}
% ------------------------------------------------------------
\begin{frame}[c]{Module}
  \begin{itemize}
  \item<1-> The assembly of subprograms can be characterized\\ by means of modules:
    \bigskip
  \item<2-> A \alert{module} \module{P} is a triple
    \(
    (P,I,O)
    \)
    consisting of
    \begin{itemize}\normalsize
    \item a (ground) program $P$ over $\ground{\mathcal{A}}$
      and
    \item sets $I,O\subseteq\ground{\mathcal{A}}$ such that
      \begin{itemize}\normalsize
      \item $I\cap O=\emptyset$,
      \item $\atom{P}\subseteq I\cup O$, and
      \item $\head{P}\subseteq O$
      \end{itemize}
    \end{itemize}
    \medskip
  \item<3-> The elements of~$I$ and~$O$ are called \alert{input} and \alert{output atoms}
    \begin{itemize}
    \item<4-> denoted by $I(\module{P})$ and $O(\module{P})$
    \end{itemize}
  \item<5-> Similarly, we refer to (ground) \alert{program}~$P$ by $P(\module{P})$
  \end{itemize}
  % We say that $\module{P}$ is \alert{input-free}, if $I(\module{P})=\emptyset$
\end{frame}
% ------------------------------------------------------------
\begin{frame}{Composing modules}
  \begin{itemize}
  \item<2-> Two modules~\module{P} and~\module{\QRG} are
    \alert{compositional}\pause[3], if
    \begin{itemize}
    \item <3->
      $\out{\module{P}}\cap\out{\module{\QRG}}=\emptyset$
      \pause[4]and
      \smallskip
    \item <4->
      $\out{\module{P}}\cap S=\emptyset$ or
      $\out{\module{\QRG}}\cap S=\emptyset$
      \\
      for every strongly connected component~$S$ of
      $\prog{\module{P}}\cup\prog{\module{\QRG}}$
    \end{itemize}
  \item<5-> \structure{Note}
    \begin{itemize}
    \item Recursion between two modules to be joined is disallowed
      \smallskip
    \item Recursion within each module is allowed
    \end{itemize}
    \medskip
  \item<6-> The \alert{join}, $\module{P} \sqcup \module{\QRG}$, of two modules
    $\module{P}$ and $\module{\QRG}$ is defined as the module
    \[
    (\; \alert<2>{P(\module{P}) \cup P(\module{\QRG})}\,,
     \; \alert<3>{(I(\module{P})\setminus O(\module{\QRG}))
                  \cup
                  (I(\module{\QRG})\setminus O(\module{P}))}\,,
     \; \alert<4>{O(\module{P}) \cup O(\module{\QRG})}
     \;)
    \]
    \alert<7>{provided that~\module{P} and~\module{\QRG} are compositional}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{Composing logic programs with externals}
  \begin{itemize}
  \item<1-> \structure{Idea} Each \lstinline{ground} instruction induces a module to be joined\\ with the module representing the current program state
    \medskip
  \item<2->
    Given an atom base $C$,
    a (non-ground) extensible program \RRG\\ induces the module
    \[ % begin{equation}\label{eq:ground:module}
      \inst{\module{\RRG}}{C}
      =
      (P,(C\cup E)\setminus\head{P},\head{P})
    \] % end{equation}
    via the ground program $P$ with externals $E$ obtained from \RRG\ and $C$
    \medskip
  \item<3-> \structure{Note}
    $E\setminus\head{P}$ consists of atoms stemming from non-overwritten\\ external declarations
\end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
  \begin{itemize}
  \item<1-> Atom base $C=\{\text{\lstinline{g(1)}}\}$
  \item<only@1,4> Extensible program $\RRG$
    \begin{semiverbatim}
  #external e(X) : f(X), g(X)
  f(1). f(2).
  a(X) :- f(X), e(X).
  b(X) :- f(X), not e(X).
    \end{semiverbatim}
    \vspace{-10pt}
  \item<only@2-3> Ground program $P$
    \begin{semiverbatim}
  f(1). f(2).
  a(1) :- f(1), e(1).
  b(1) :- f(1), not e(1).   b(2) :- f(2).
    \end{semiverbatim}
    \vspace{-13pt}
  \item<only@2-3>[] with externals $E=\{\text{\lstinline{e(1)}}\}$
  \item<3-> Module
    \(
    \inst{\module{\RRG}}{C}=(P,(C\cup E)\setminus\head{P},\head{P})
    \)
    \[
    \hspace{-15pt}
    {} =
    \left(
      \left\{
        \begin{array}{l}
          f(1), \  f(2), \\
          a(1) \leftarrow f(1), e(1),\\
          b(1) \leftarrow f(1), \naf{e(1)},\\
          b(2) \leftarrow f(2)
        \end{array}
      \right\}
      ,
      \left\{
        \begin{array}[l]{l}
          g(1),\\e(1)
        \end{array}
      \right\}
      ,
      \left\{
        \begin{array}[l]{l}
          f(1), \  f(2), \\
          a(1),\\
          b(1), b(2)
        \end{array}
      \right\}
    \right)
    \]
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{Capturing program states by modules}
  \begin{itemize}
  \item<1-> Each program state is captured by a module
    \begin{itemize}
    \item<2-> The input and output atoms of each module provide the atom base
    \end{itemize}
    \medskip
  \item<3-> The initial program state is given by the empty module
    \[
    \module{P}_0 = (\emptyset,\emptyset,\emptyset)
    \]
  \item<4->
    The program state succeeding~$\module{P}_i$ is captured by the module
    \[ % begin{equation}\label{eq:module:composition}
      \module{P}_{i+1}
      =
      \module{P}_i
      \sqcup
      \inst{\module{\RRG}_{i+1}}{\inp{\module{P}_i}\cup\out{\module{P}_i}}
    \] % end{equation}
    where
    \(
    \inst{\module{\RRG}_{i+1}}{\inp{\module{P}_i}\cup\out{\module{P}_i}}
    \)
    captures the result of grounding an extensible program \RRG\ relative to atom base $\inp{\module{P}_i}\cup\out{\module{P}_i}$
    \smallskip
  \item<5-> \structure{Note} The join leading to $\module{P}_{i+1}$ can be undefined in case the constituent modules are non-compositional
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{Capturing program states by modules}
  \begin{itemize}
  \item<1->
Let $(\RRG_i)_{i>0}$ be a sequence of (non-ground) extensible programs,
and let
$P_{i+1}$ be the ground program with externals $E_{i+1}$ obtained from $\RRG_{i+1}$ and $\inp{\module{P}_i}\cup\out{\module{P}_i}$
\bigskip
\item<2->[]
If
\(
\bigsqcup_{i\geq 0}\module{P}_i
\)
is compositional,
then
\medskip
\begin{enumerate}\normalsize
\item
\(
\prog{\bigsqcup_{i\geq 0}\module{P}_i}
=
\bigcup_{i>0} P_i
\)
\smallskip
\item
\(
\;\inp{\bigsqcup_{i\geq 0}\module{P}_i}
=
\bigcup_{i>0} E_i\setminus\bigcup_{i>0} \head{P_i}
\)
\smallskip
\item
\(
\out{\bigsqcup_{i\geq 0}\module{P}_i}
=
\bigcup_{i>0} \head{P_i}
\)
\end{enumerate}
\end{itemize}
\end{frame}
% ------------------------------------------------------------
\section{States and operations}
% ------------------------------------------------------------
\begin{frame}{Clingo state}
  \begin{itemize}
  \item<1-> A \alert{\clingo\ state} is a triple
    \[
    ( \boldsymbol{R},\module{P},V )
    \]
    where

    \begin{itemize}\normalsize
    \item $\boldsymbol{R}\only<2->{=\left(\RRG_c\right)_{c\in\mathcal{C}}}$ is a collection of extensible (non-ground) logic programs
      \only<2->{where $\mathcal{C}$ is the set of all non-integer constants}
      \smallskip
    \item $\module{P}$ is a module
      \smallskip
    \item $V\only<3->{=( V^t,V^u )}$ is a three-valued assignment over $\inp{\module{P}}$
      \only<3->{\par where $V^f=\inp{\module{P}}\setminus (V^t\cup V^u)$}
    \end{itemize}
    \medskip
  \item<only@4-> \structure{Note} Input atoms in $\inp{\module{P}}$ are taken to be false by default
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{create}
  \begin{itemize}
  \item $\mathit{create}(R): {} \mapsto ( \boldsymbol{R},\module{P},V )$
    \smallskip
  \item []
    for a list $R$ of (non-ground) rules and declarations
    \pause[2]%
    where
    \smallskip
    \begin{itemize}\normalsize
    \item $\boldsymbol{R}=\left(\RRG(c)\right)_{c\in\mathcal{C}}$
    \item $\,\module{P} = (\emptyset,\emptyset,\emptyset)$
    \item $V=(\emptyset,\emptyset)$
    \end{itemize}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{add}
  \begin{itemize}
  \item $\mathit{add}(R): ( \boldsymbol{R}_1,\module{P},V )\mapsto( \boldsymbol{R}_2,\module{P},V )$
    \smallskip
  \item []
    for a list $R$ of (non-ground) rules and declarations
    \pause[2]%
    where
    \smallskip
    \begin{itemize}\normalsize
    \item $\boldsymbol{R}_1=\left(\RRG_c\right)_{c\in\mathcal{C}}$ and
          $\boldsymbol{R}_2=\left(\RRG_c\cup\RRG(c)\right)_{c\in\mathcal{C}}$
    \end{itemize}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{ground}
  \begin{itemize}
  \item $\mathit{ground}((n,\boldsymbol{p}_n)_{n\in N}): ( \boldsymbol{R},\module{P}_1,V_1 )\mapsto(\boldsymbol{R},\module{P}_2,V_2 )$
    \smallskip
  \item []
    for a collection $(n,\boldsymbol{p}_n)_{n\in N}$ such that $N\subseteq\mathcal{C}$ and $\boldsymbol{p}_n\in\mathcal{T}^k$ for some $k$
    \pause[2]%
    \smallskip
    where
    \smallskip
    \begin{itemize}\normalsize
    \item $\module{P}_2=\module{P}_1\sqcup\inst{\module{R}}{\inp{\module{P}_1}\cup\out{\module{P}_1}}$
      \par\smallskip
      and
      \inst{\module{R}}{\inp{\module{P}_1}\cup\out{\module{P}_1}}
      is the module obtained from
      \begin{itemize}\normalsize
      \item extensible program
        \(
        \bigcup_{n\in N}R_n[\boldsymbol{p}/\boldsymbol{p}_n]
        \)
        and
      \item atom base $\inp{\module{P}_1}\cup\out{\module{P}_1}$
      \end{itemize}
      for $\left(\RRG_c\right)_{c\in\mathcal{C}}=\boldsymbol{R}$
      \smallskip
    \item   $V_2^t\,=\{a\in\inp{\module{P}_2}\mid V_1(a)=t\,\}$
    \item[] $V_2^u  =\{a\in\inp{\module{P}_2}\mid V_1(a)=u  \}$
    \end{itemize}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{ground}
  \begin{itemize}
  \item \structure{Notes}
    \begin{itemize}\normalsize
    \item The external status of an atom is eliminated once it becomes defined by a rule in some added program
      \par
      This is accomplished by module composition, namely, the elimination of output atoms from input atoms
    \smallskip
    \item<2-> Jointly grounded subprograms are treated as a single subprogram
    \smallskip
    \item<3->  $\mathit{ground}((n,\boldsymbol{p}),(n,\boldsymbol{p}))(s)=\mathit{ground}((n,\boldsymbol{p}))(s)$ while
        $\mathit{ground}((n,\boldsymbol{p}))(\mathit{ground}((n,\boldsymbol{p}))(s))$
        leads to two non-compositional modules whenever $\head{R_n}\neq\emptyset$
    \smallskip
    \item<4-> Inputs stemming from added external declarations are set to false
    \end{itemize}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{assignExternal}
  \begin{itemize}
  \item $\mathit{assignExternal}(a,v): ( \boldsymbol{R},\module{P},V_1 )\mapsto(\boldsymbol{R},\module{P},V_2 )$
    \smallskip
  \item [] for a ground atom $a$ and $v\in\{t,u,f\}$\pause[2] where
    \medskip
    \begin{itemize}\normalsize
    \item if $v=t$
      \begin{itemize}\normalsize
      \item $V_2^t\,=V_1^t\cup\{a\}$ if $a\in\inp{\module{P}}$, and $V_2^t=V_1^t$ otherwise
      \item $V_2^u  =V_1^u\setminus\{a\}$
      \end{itemize}
    \item if $v=u$
      \begin{itemize}\normalsize
      \item $V_2^t\,=V_1^t\,\setminus\{a\}$
      \item $V_2^u  =V_1^u\cup\{a\}$ if $a\in\inp{\module{P}}$, and $V_2^u=V_1^u$ otherwise
      \end{itemize}
    \item if $v=f$
      \begin{itemize}\normalsize
      \item $V_2^t\,=V_1^t\setminus\{a\}$
      \item $V_2^u  =V_1^u\setminus\{a\}$
      \end{itemize}
    \end{itemize}
    \smallskip
  \item<3-> \structure{Note} Only input atoms, that is, non-overwritten externals are affected
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{releaseExternal}
  \begin{itemize}
  \item $\mathit{releaseExternal}(a): ( \boldsymbol{R},\module{P}_1,V_1 )\mapsto(\boldsymbol{R},\module{P}_2 ,V_2 )$
    \smallskip
  \item []
    for a ground atom~$a$
    \pause[2]%
    \smallskip
    where
    \smallskip
    \begin{itemize}\normalsize
    \item $\module{P}_2=(\prog{\module{P}_1},\inp{\module{P}_1}\setminus\{a\},\out{\module{P}_1}\cup\{a\})$ if $a\in\inp{\module{P}_1}$,
      and $\module{P}_2=\module{P}_1$ otherwise
    \item $V_2^t\,=V_1^t\,\setminus\{a\}$
    \item [] $V_2^u  =V_1^u  \setminus\{a\}$
    \end{itemize}
  \item<3-> \structure{Notes}
    \begin{itemize}
    \item<3-> \textit{releaseExternal} only affects input atoms; defined atoms remain unaffected
    \item<4-> A released atom can never be re-defined, neither by a rule nor an external declaration
    \item<5-> A released (input) atom is made permanently false, since it is neither defined by any rule nor part of the input atoms
    \end{itemize}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{solve}
  \begin{itemize}
  \item $\mathit{solve}(( A^t,A^f )): ( \boldsymbol{R},\module{P},V )\mapsto( \boldsymbol{R},\module{P},V )$
    prints the set
    \[
    \{X\mid X\text{ is a stable model of }\module{P}\text{ wrt }V\text{ st }A^t\subseteq X\text{ and }A^f\cap X = \emptyset\}
    \]
    \pause[2]%
    where the stable models of a module \module{P} wrt an assignment $V$
    \par
    are given by the stable models of the program
    \[
    \prog{\module{P}}\cup\{{a\leftarrow{}}\mid a\in V^t\}\cup\{{\{a\}\leftarrow{}}\mid a\in V^u\}
    \]
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{\texttt{\#script} declaration}
  \begin{itemize}
  \item A \alert{script declaration} is of form
    \[
    \texttt{\#script(python)} \ P \ \texttt{\#end}
    \]
    where $P$ is a Python program
  \item<2> Analogously for Lua
  \item<4-> \alert{\texttt{main}} routine exercises control\pause[5] \alert<5>{(from within \clingo, not from Python)}
  \item<6-> \structure{Example\only<7>{s}}
    \par\medskip\footnotesize
    \begin{minipage}{0.4\linewidth}
\begin{semiverbatim}
#script(python)
def main(prg):
    prg.ground([("base",[])])
    prg.solve()
#end.
\end{semiverbatim}
    \end{minipage}
    \qquad\pause[7]
    \begin{minipage}{0.4\linewidth}
\begin{semiverbatim}
#script(python)
def main(prg):
    prg.ground([("acid",[42])])
    prg.solve()
#end.
\end{semiverbatim}
    \end{minipage}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
\scriptsize\vspace{-10pt}%
\begin{semiverbatim}
   \alert<3>{#external p(1;2;3).}
   \alert<3>{p(0) :- p(3).}
   \alert<3>{p(0) :- not p(0).}

   \alert<3>{#program succ(n).}
   \alert<3>{#external p(n+3).}
   \alert<3>{p(n) :- p(n+3).}
   \alert<3>{p(n) :- not p(n+1), not p(n+2).}

   \alert<2>{#script(python)}
   from clingo import Fun
   \alert<2>{def main(\alert<3>{prg})}:
       prg.ground([("base", [])])
       prg.assign_external(Fun("p", [3]), True)
       prg.solve()
       prg.assign_external(Fun("p", [3]), False)
       prg.solve()
       prg.ground([("succ", [1]),("succ", [2])])
       prg.solve()
       prg.ground([("succ", [3])])
       prg.solve()
   \alert<2>{#end}.
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{Extensible programs}
  \begin{itemize}
  \item Initial \clingo\ state\only<3->{, or more precisely, state of \alert{\clingo\ object `\texttt{prg}'}}
    \[
    \only<-3>{(\boldsymbol{\RRG}_0,\module{P}_0,V_0 )}\only<4->{\hspace{10pt}\mathit{create}(R)}
    =
    (
    (\RRG(\mathtt{base}),\RRG(\mathtt{succ})),(\emptyset,\emptyset,\emptyset),(\emptyset,\emptyset)
    )
    \]
  \item[] where \only<4->{$R$ is the list of rules and declarations in Line~1-8 and}
    \begin{align*}
      \RRG(\mathtt{base})
      &=
      \left\{
        \begin{array}{ll}
          \texttt{\#external}~p(1) & p(0)\leftarrow p(3)      \\
          \texttt{\#external}~p(2) & p(0)\leftarrow \naf{p(0)}\\
          \texttt{\#external}~p(3) &\\
        \end{array}
      \right\}
      \\[10pt]
      \RRG(\mathtt{succ})
      &=
      \left\{
        \begin{array}{l}
          \texttt{\#external}~p(n+3)\\
          p(n)\leftarrow p(n+3)\\
          p(n)\leftarrow \naf{p(n+1)},\naf{p(n+2)}
        \end{array}
      \right\}
    \end{align*}
  \item<2-> Initial atom base
    \(
    \inp{\module{P}_0}\cup\out{\module{P}_0}=\emptyset
    \)
    \only<-4>{\vspace{16pt}}
  \item <only@5> \structure{Note} $\mathit{create}(R)$ is invoked implicitly to create \clingo\ object `\texttt{prg}'
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
\scriptsize\vspace{-10pt}%
\begin{semiverbatim}
   #external p(1;2;3).
   p(0) :- p(3).
   p(0) :- not p(0).

   #program succ(n).
   #external p(n+3).
   p(n) :- p(n+3).
   p(n) :- not p(n+1), not p(n+2).

   #script(python)
   from clingo import Fun
   def main(prg):
\only<2>{\alert{>>}}\only<1>{  }     \alert<2>{prg.ground([("base", [])])}
       prg.assign_external(Fun("p", [3]), True)
       prg.solve()
       prg.assign_external(Fun("p", [3]), False)
       prg.solve()
       prg.ground([("succ", [1]),("succ", [2])])
       prg.solve()
       prg.ground([("succ", [3])])
       prg.solve()
   #end.
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{\texttt{prg.ground([("base", [])])}}
  \begin{itemize}
  \item \structure{Global} \clingo\ state $(\boldsymbol{\RRG}_0,\module{P}_0,V_0 )$, including atom base $\emptyset$
  \item \structure{Input}  Extensible program $\RRG(\mathtt{base})$
  \item<2-> \structure{Output} Module
      \begin{align*}
        \inst{\module{\RRG}_1}{\emptyset} & {} = (P_1,E_1,\{p(0)\})   \qquad\text{ where}\\
        P_1 & {} = \{p(0)\leftarrow p(3);\ p(0)\leftarrow \naf{p(0)}\}             \\
        E_1 & {} = \{p(1),p(2),p(3)\}
      \end{align*}
  \item<3-> \structure{Result} \clingo\ state
    \[
    \hspace{-10pt}
    (\boldsymbol{\RRG}_1,\module{P}_1,V_1 )
    =
    (
     \boldsymbol{\RRG}_0,\module{P}_0 \sqcup \inst{\module{\RRG}_1}{\emptyset},V_0
    )
    \]
    where
    \begin{align*}
    \hspace{-10pt}
      \module{P}_1
      & {} =
      \module{P}_0 \sqcup \inst{\module{\RRG}_1}{\emptyset}
      \pause[4] =
      (\emptyset,\emptyset,\emptyset) \sqcup (P_1,E_1,\{p(0)\})\\
      &\pause[5] {} =
      (
      \{
      p(0)\leftarrow p(3);\
      p(0)\leftarrow \naf{p(0)}
      \},
      \{p(1),p(2),p(3)\},
      \{p(0)\}
      )
    \end{align*}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
\scriptsize\vspace{-10pt}%
\begin{semiverbatim}
   #external p(1;2;3).
   p(0) :- p(3).
   p(0) :- not p(0).

   #program succ(n).
   #external p(n+3).
   p(n) :- p(n+3).
   p(n) :- not p(n+1), not p(n+2).

   #script(python)
   from clingo import Fun
   def main(prg):
\only<1>{\alert{>>}}\only<2>{  }     \alert<1>{prg.ground([("base", [])])}
\only<2>{\alert{>>}}\only<1>{  }     \alert<2>{prg.assign_external(Fun("p", [3]), True)}
       prg.solve()
       prg.assign_external(Fun("p", [3]), False)
       prg.solve()
       prg.ground([("succ", [1]),("succ", [2])])
       prg.solve()
       prg.ground([("succ", [3])])
       prg.solve()
   #end.
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{\texttt{prg.assign\_external(Fun("p",[3]),True)}}
  \begin{itemize}
  \item \structure{Global} \clingo\ state $(\boldsymbol{\RRG}_1,\module{P}_1,V_1 )$
  \item \structure{Input} \ assignment \ $p(3)\mapsto t$
    \medskip
  \item<2-> \structure{Result} \clingo\ state
    \[
    (\boldsymbol{\RRG}_2,\module{P}_2,V_2 )
    =
    (\boldsymbol{\RRG}_0,\module{P}_1,(\{p(3)\},\emptyset))
    \]
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
\scriptsize\vspace{-10pt}%
\begin{semiverbatim}
   #external p(1;2;3).
   p(0) :- p(3).
   p(0) :- not p(0).

   #program succ(n).
   #external p(n+3).
   p(n) :- p(n+3).
   p(n) :- not p(n+1), not p(n+2).

   #script(python)
   from clingo import Fun
   def main(prg):
       prg.ground([("base", [])])
\only<1>{\alert{>>}}\only<2>{  }     \alert<1>{prg.assign_external(Fun("p", [3]), True)}
\only<2>{\alert{>>}}\only<1>{  }     \alert<2>{prg.solve()}
       prg.assign_external(Fun("p", [3]), False)
       prg.solve()
       prg.ground([("succ", [1]),("succ", [2])])
       prg.solve()
       prg.ground([("succ", [3])])
       prg.solve()
   #end.
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{\texttt{prg.solve()}}
  \begin{itemize}
  \item \structure{Global} \clingo\ state $(\boldsymbol{\RRG}_2,\module{P}_2,V_2 )$
  \item \structure{Input} \ empty assignment
    \medskip
  \item<2-> \structure{Result} \clingo\ state
    \[
      (\boldsymbol{\RRG}_2,\module{P}_2,V_2 )\pause[3]
    = (\boldsymbol{\RRG}_0,\module{P}_1,(\{p(3)\},\emptyset))
    \]
  \item<4->\structure{Print}  stable model $\{p(0),p(3)\}$ of~$\module{P}_2$ wrt $V_2$
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
\scriptsize\vspace{-10pt}%
\begin{semiverbatim}
   #external p(1;2;3).
   p(0) :- p(3).
   p(0) :- not p(0).

   #program succ(n).
   #external p(n+3).
   p(n) :- p(n+3).
   p(n) :- not p(n+1), not p(n+2).

   #script(python)
   from clingo import Fun
   def main(prg):
       prg.ground([("base", [])])
       prg.assign_external(Fun("p", [3]), True)
\only<1>{\alert{>>}}\only<2>{  }     \alert<1>{prg.solve()}
\only<2>{\alert{>>}}\only<1>{  }     \alert<2>{prg.assign_external(Fun("p", [3]), False)}
       prg.solve()
       prg.ground([("succ", [1]),("succ", [2])])
       prg.solve()
       prg.ground([("succ", [3])])
       prg.solve()
   #end.
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{\texttt{prg.assign\_external(Fun("p",[3]),False)}}
  \begin{itemize}
  \item \structure{Global} \clingo\ state $(\boldsymbol{\RRG}_2,\module{P}_2,V_2 )$
  \item \structure{Input} \ assignment \ $p(3)\mapsto f$
    \medskip
  \item<2-> \structure{Result} \clingo\ state
    \[
    (\boldsymbol{\RRG}_3,\module{P}_3,V_3 )
    =
    (\boldsymbol{\RRG}_0,\module{P}_1,(\emptyset,\emptyset))
    \]
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
\scriptsize\vspace{-10pt}%
\begin{semiverbatim}
   #external p(1;2;3).
   p(0) :- p(3).
   p(0) :- not p(0).

   #program succ(n).
   #external p(n+3).
   p(n) :- p(n+3).
   p(n) :- not p(n+1), not p(n+2).

   #script(python)
   from clingo import Fun
   def main(prg):
       prg.ground([("base", [])])
       prg.assign_external(Fun("p", [3]), True)
       prg.solve()
\only<1>{\alert{>>}}\only<2>{  }     \alert<1>{prg.assign_external(Fun("p", [3]), False)}
\only<2>{\alert{>>}}\only<1>{  }     \alert<2>{prg.solve()}
       prg.ground([("succ", [1]),("succ", [2])])
       prg.solve()
       prg.ground([("succ", [3])])
       prg.solve()
   #end.
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{\texttt{prg.solve()}}
  \begin{itemize}
  \item \structure{Global} \clingo\ state $(\boldsymbol{\RRG}_3,\module{P}_3,V_3 )$
  \item \structure{Input} \ empty assignment
    \medskip
  \item<2-> \structure{Result} \clingo\ state
    \[
      (\boldsymbol{\RRG}_3,\module{P}_3,V_3 )
    = (\boldsymbol{\RRG}_0,\module{P}_1,(\emptyset,\emptyset) )
    \]
  \item<3->\structure{Print} no stable model of~$\module{P}_3$ wrt $V_3$
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
\scriptsize\vspace{-10pt}%
\begin{semiverbatim}
   #external p(1;2;3).
   p(0) :- p(3).
   p(0) :- not p(0).

   #program succ(n).
   #external p(n+3).
   p(n) :- p(n+3).
   p(n) :- not p(n+1), not p(n+2).

   #script(python)
   from clingo import Fun
   def main(prg):
       prg.ground([("base", [])])
       prg.assign_external(Fun("p", [3]), True)
       prg.solve()
       prg.assign_external(Fun("p", [3]), False)
\only<1>{\alert{>>}}\only<2>{  }     \alert<1>{prg.solve()}
\only<2>{\alert{>>}}\only<1>{  }     \alert<2>{prg.ground([("succ", [1]),("succ", [2])])}
       prg.solve()
       prg.ground([("succ", [3])])
       prg.solve()
   #end.
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{\texttt{prg.ground([("succ",[1]),("succ",[2])])}}
  \begin{itemize}
  \item \structure{Global} \clingo\ state $(\boldsymbol{\RRG}_3,\module{P}_3,V_3 )$, including atom base
    \\\qquad\quad
    \(
    \inp{\module{P}_3}\cup\out{\module{P}_3}=\{p(0),p(1),p(2),p(3)\}
    \)
  \item \structure{Input} Extensible program
    \(
    \RRG(\mathtt{succ})[\mathtt{n}/\mathtt{1}]\cup\RRG(\mathtt{succ})[\mathtt{n}/\mathtt{2}]
    \)
  \item<2-> \structure{Output} Module
    \begin{align*}
      \inst{\module{\RRG}_4}{\inp{\module{P}_3}\cup\out{\module{P}_3}}
      &=
        \left(
        P_4
        ,
        \left\{
        \begin{array}{@{}l@{}}
          p(0),p(4),
          \\
          p(3),p(5)
        \end{array}
      \right\}
      ,
      \left\{
      \begin{array}{@{}l@{}}
        p(1),\\p(2)
      \end{array}
      \right\}
      \right)
      \ \text{ where}\\
      P_4 & {} =
               \left\{
               \begin{array}{@{}l@{}}
                 p(1)\leftarrow p(4);\ p(1)\leftarrow \naf{p(2)},\naf{p(3)};
                 \\
                 p(2)\leftarrow p(5);\ p(2)\leftarrow \naf{p(3)},\naf{p(4)}
               \end{array}
      \right\}\\
      E_4 & {} = \{p(4),p(5)\}
    \end{align*}
    % ???    \medskip
  \item<2-> \structure{Result} \clingo\ state
    \[
    (\boldsymbol{\RRG}_4,\module{P}_4,V_4 )
    =
    (\boldsymbol{\RRG}_0,\module{P}_3\sqcup\inst{\module{\RRG}_4}{\inp{\module{P}_3}\cup\out{\module{P}_3}},V_3)
    \]
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{\texttt{prg.ground([("succ",[1]),("succ",[2])])}}
  \begin{itemize}
  \item<2-> \structure{Result} \clingo\ state
    \[
    (\boldsymbol{\RRG}_4,\module{P}_4,V_4 )
    =
    (\boldsymbol{\RRG}_0,\module{P}_3\sqcup\inst{\module{\RRG}_4}{\inp{\module{P}_3}\cup\out{\module{P}_3}},V_3)
    \]
  \item<3->[] where\scriptsize
    \begin{align*}
      \hspace{-30pt}
      \module{P}_4 % ----------------------------------------------------------------------------------------------
      & =
        \left(\!
        \left\{
        \begin{array}{@{\!}l@{\!}}
          \alert<4>{p(0)\leftarrow p(3)};\quad   \alert<5>{p(1)\leftarrow p(4)};\ \alert<5>{p(1)\leftarrow \naf{p(2)},\naf{p(3)}};
          \\
          \alert<4>{p(0)\leftarrow \naf{p(0)}};\ \alert<5>{p(2)\leftarrow p(5)};\ \alert<5>{p(2)\leftarrow \naf{p(3)},\naf{p(4)}}
        \end{array}
      \right\}
      \!,\!
      \left\{
      \begin{array}{@{\!}l@{\!}}
        \phantom{p(3),}\, \alert<7>{p(4)},
        \\
        \alert<6,7>{p(3)},\alert<7>{p(5)}
      \end{array}
      \right\}
      \!,\!
      \left\{
      \begin{array}{@{\!}l@{\!}}
        \alert<8>{p(0)},\alert<9>{p(1)},
        \\
        \phantom{p(0),}\,\alert<9>{p(2)}
      \end{array}
      \right\}\!
      \right)
    \end{align*}
  \item<3-> [] \scriptsize
    \begin{align*}
      \module{P}_3 % ----------------------------------------------------------------------------------------------
      & {} =
        \left(
        \left\{
        \begin{array}{@{}l@{}}
          \alert<4>{p(0)\leftarrow p(3)};\\
          \alert<4>{p(0)\leftarrow \naf{p(0)}}
        \end{array}
      \right\},
      \{\textcolor<6>{red}{p(1)},\textcolor<6>{red}{p(2)},\alert<6>{p(3)}\},
      \{\alert<8>{\textcolor<7>{red}{p(0)}}\}
      \right)
      \\[5pt]
      \hspace{-30pt}
      \inst{\module{\RRG}_4}{\inp{\module{P}_3}\cup\out{\module{P}_3}} % ----------------------------------------
      &=
        \left(
        \left\{
        \begin{array}{@{}l@{}}
          \alert<5>{p(1)\leftarrow p(4)};\ \alert<5>{p(1)\leftarrow \naf{p(2)},\naf{p(3)}};
          \\
          \alert<5>{p(2)\leftarrow p(5)};\ \alert<5>{p(2)\leftarrow \naf{p(3)},\naf{p(4)}}
        \end{array}
      \right\}
      ,
      \left\{
      \begin{array}{@{}l@{}}
        \textcolor<7>{red}{p(0)},\alert<7>{p(4)},
        \\
        \alert<7>{p(3)},\alert<7>{p(5)}
      \end{array}
      \right\}
      ,
      \left\{
      \begin{array}{@{}l@{}}
        \alert<9>{\textcolor<6>{red}{p(1)}},\\\alert<9>{\textcolor<6>{red}{p(2)}}
      \end{array}
      \right\}
      \right)
    \end{align*}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
\scriptsize\vspace{-10pt}%
\begin{semiverbatim}
   #external p(1;2;3).
   p(0) :- p(3).
   p(0) :- not p(0).

   #program succ(n).
   #external p(n+3).
   p(n) :- p(n+3).
   p(n) :- not p(n+1), not p(n+2).

   #script(python)
   from clingo import Fun
   def main(prg):
       prg.ground([("base", [])])
       prg.assign_external(Fun("p", [3]), True)
       prg.solve()
       prg.assign_external(Fun("p", [3]), False)
       prg.solve()
\only<1>{\alert{>>}}\only<2>{  }     \alert<1>{prg.ground([("succ", [1]),("succ", [2])])}
\only<2>{\alert{>>}}\only<1>{  }     \alert<2>{prg.solve()}
       prg.ground([("succ", [3])])
       prg.solve()
   #end.
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{\texttt{prg.solve()}}
  \begin{itemize}
  \item \structure{Global} \clingo\ state $(\boldsymbol{\RRG}_4,\module{P}_4,V_4 )$
  \item \structure{Input} \ empty assignment
    \medskip
  \item<2-> \structure{Result} \clingo\ state
    \[
      (\boldsymbol{\RRG}_4,\module{P}_4,V_4 )
    = (\boldsymbol{\RRG}_0,\module{P}_4,V_3 )
    \]
  \item<3->\structure{Print} no stable model of~$\module{P}_4$ wrt $V_4$
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
\scriptsize\vspace{-10pt}%
\begin{semiverbatim}
   #external p(1;2;3).
   p(0) :- p(3).
   p(0) :- not p(0).

   #program succ(n).
   #external p(n+3).
   p(n) :- p(n+3).
   p(n) :- not p(n+1), not p(n+2).

   #script(python)
   from clingo import Fun
   def main(prg):
       prg.ground([("base", [])])
       prg.assign_external(Fun("p", [3]), True)
       prg.solve()
       prg.assign_external(Fun("p", [3]), False)
       prg.solve()
       prg.ground([("succ", [1]),("succ", [2])])
\only<1>{\alert{>>}}\only<2>{  }     \alert<1>{prg.solve()}
\only<2>{\alert{>>}}\only<1>{  }     \alert<2>{prg.ground([("succ", [3])])}
       prg.solve()
   #end.
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{\texttt{prg.ground([("succ", [3])])}}
  \begin{itemize}
  \item \structure{Global} \clingo\ state $(\boldsymbol{\RRG}_4,\module{P}_4,V_4 )$, including atom base
    \\\qquad\quad
    \(
    {\inp{\module{P}_4}\cup\out{\module{P}_4}}=\{p(0),p(1),p(2),p(3),p(4),p(5)\}
    \)
  \item \structure{Input} \ Extensible program
    \(
    \RRG(\mathtt{succ})[\mathtt{n}/\mathtt{3}]
    \)
  \item<2-> \structure{Output} Module
    \begin{align*}
      \inst{\module{\RRG}_5}{\inp{\module{P}_4}\cup\out{\module{P}_4}}
      &{}=
        \left(
        P_5%\{p(3)\leftarrow p(6);\ p(3)\leftarrow \naf{p(4)},\naf{p(5)}\}
        ,
        \left\{
        \begin{array}{@{}l@{}}
          p(0),p(1),p(2),
          \\
          p(4),p(5),p(6)
        \end{array}
      \right\}
      ,
      \left\{
      p(3)
      \right\}
      \right)
      \\ \text{where }
      P_5 & {} = \{p(3)\leftarrow p(6);\ p(3)\leftarrow \naf{p(4)},\naf{p(5)}\}\\
      E_5 & {} = \{p(6)\}
    \end{align*}
  \item<3-> \structure{Result} \clingo\ state
    \[
    (\boldsymbol{\RRG}_5,\module{P}_5,V_5 )
    =
    (\boldsymbol{\RRG}_0,\module{P}_4\sqcup\inst{\module{\RRG}_5}{\inp{\module{P}_4}\cup\out{\module{P}_4}},V_3)
    \]
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{\texttt{prg.ground([("succ", [3])])}}
  \begin{itemize}
  \item \structure{Result} \clingo\ state
    \[
    (\boldsymbol{\RRG}_5,\module{P}_5,V_5 )
    =
    (\boldsymbol{\RRG}_0,\module{P}_4\sqcup\inst{\module{\RRG}_5}{\inp{\module{P}_4}\cup\out{\module{P}_4}},V_3)
    \]
    where
    \begin{align*}
      \boldsymbol{\RRG}_5 & {} = (\RRG(\mathtt{base}),\RRG(\mathtt{succ}))
      \\[10pt]
      \prog{\module{P}_5}
      & {} =
      \left\{
        \begin{array}{@{}l@{}}
          p(0)\leftarrow p(3);\quad   p(1)\leftarrow p(4);\ p(1)\leftarrow \naf{p(2)},\naf{p(3)};
          \\
          p(0)\leftarrow \naf{p(0)};\ p(2)\leftarrow p(5);\ p(2)\leftarrow \naf{p(3)},\naf{p(4)};
          \\
          \phantom{p(0)\leftarrow \naf{p(0)};\ }\,p(3)\leftarrow p(6);\ p(3)\leftarrow \naf{p(4)},\naf{p(5)}
        \end{array}
      \right\}
      \\
      \inp{\module{P}_5}
      & {} =
      \left\{
        p(4),
        p(5),
        p(6)
      \right\}
      \\
      \out{\module{P}_5}
      & {} =
      \left\{
        p(0),p(1),p(2), p(3)
      \right\}
      \\[10pt]
      V_5 & {} = (\emptyset,\emptyset)
    \end{align*}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Example}
\scriptsize\vspace{-10pt}%
\begin{semiverbatim}
   #external p(1;2;3).
   p(0) :- p(3).
   p(0) :- not p(0).

   #program succ(n).
   #external p(n+3).
   p(n) :- p(n+3).
   p(n) :- not p(n+1), not p(n+2).

   #script(python)
   from clingo import Fun
   def main(prg):
       prg.ground([("base", [])])
       prg.assign_external(Fun("p", [3]), True)
       prg.solve()
       prg.assign_external(Fun("p", [3]), False)
       prg.solve()
       prg.ground([("succ", [1]),("succ", [2])])
       prg.solve()
\only<1>{\alert{>>}}\only<2>{  }     \alert<1>{prg.ground([("succ", [3])])}
\only<2>{\alert{>>}}\only<1>{  }     \alert<2>{prg.solve()}
   #end.
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}{\texttt{prg.solve()}}
  \begin{itemize}
  \item \structure{Global} \clingo\ state $(\boldsymbol{\RRG}_5,\module{P}_5,V_5 )$
  \item \structure{Input} \ empty assignment
    \medskip
  \item<2-> \structure{Result} \clingo\ state
    \[
      (\boldsymbol{\RRG}_5,\module{P}_5,V_5 )
    = (\boldsymbol{\RRG}_0,\module{P}_5,V_3 )
    \]
  \item<3->\structure{Print}  stable model $\{p(0),p(3)\}$ of~$\module{P}_5$ wrt $V_5$
  \end{itemize}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{\texttt{simple.lp}}
\scriptsize\vspace{-10pt}%
\begin{semiverbatim}
   #external p(1;2;3).
   p(0) :- p(3).
   p(0) :- not p(0).

   #program succ(n).
   #external p(n+3).
   p(n) :- p(n+3).
   p(n) :- not p(n+1), not p(n+2).

   #script(python)
   from clingo import Fun
   def main(prg):
       prg.ground([("base", [])])
       prg.assign_external(Fun("p", [3]), True)
       prg.solve()
       prg.assign_external(Fun("p", [3]), False)
       prg.solve()
       prg.ground([("succ", [1]),("succ", [2])])
       prg.solve()
       prg.ground([("succ", [3])])
       prg.solve()
   #end.
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Clingo on the run}
\footnotesize
\begin{semiverbatim}
$ clingo simple.lp\pause[2]
clingo version 4.5.0
Reading from simple.lp
Solving...
Answer: 1
p(3) p(0)
Solving...
Solving...
Solving...
Answer: 1
p(3) p(0)
SATISFIABLE

Models       : 2+
Calls        : 4
Time         : 0.019s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.010s
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\section{Incremental reasoning}
% ------------------------------------------------------------
\newcommand{\hanoiInstance}{
	\begin{tikzpicture}[->,>=stealth',semithick]
		% peg a 0.0 - 3.0
		\draw (0.1,0)   rectangle node {1} (2.9,0.5);
		\draw (1.4,0.5) rectangle          (1.6,2.1);
		\draw [-] (1.5,2.1) node [above] {a};
		% peg b 3.0 - 6.0
		\draw (3.3,0)   rectangle node {2} (5.7,0.5);
		\draw (4.3,0.5) rectangle node {7} (4.7,1);
		\draw (4.4,1)   rectangle          (4.6,2.1);
		\draw [-] (4.5,2.1) node [above] {b};
		% peg c 6.0 - 9.0
		\draw (6.5,0)   rectangle node {3} (8.5,0.5);
		\draw (6.7,0.5) rectangle node {4} (8.3,1);
		\draw (6.9,1)   rectangle node {5} (8.1,1.5);
		\draw (7.1,1.5) rectangle node {6} (7.9,2);
		\draw (7.4,2)   rectangle          (7.6,2.1);
		\draw [-] (7.5,2.1) node [above] {c};
	\end{tikzpicture}
}
% ------------------------------------------------------------
\begin{frame}[fragile,c]{Towers of Hanoi Instance}
  \centering
  \bigskip
  \hanoiInstance
  \bigskip
  \pause
\begin{semiverbatim}
peg(a;b;c).   disk(1..7).

    init_on(1,a).  init_on((2;7),b).  init_on((3;4;5;6),c).
goal_on((3;4),a).                   goal_on((1;2;5;6;7),c).
\end{semiverbatim}
\end{frame}

% ------------------------------------------------------------
\begin{frame}[fragile]{Towers of Hanoi Encoding}
\begin{semiverbatim}
{\bf\#program} base.

on(D,P,0) :- init_on(D,P).
\end{semiverbatim}
\end{frame}

% ------------------------------------------------------------
\begin{frame}[fragile]{Towers of Hanoi Encoding}
\begin{semiverbatim}
{\bf\#program} step(t).

1 \{ move(D,P,t) : disk(D), peg(P) \} 1.

moved(D,t) :- move(D,_,t).
blocked(D,P,t) :- on(D+1,P,t-1), disk(D+1).
blocked(D,P,t) :- blocked(D+1,P,t), disk(D+1).
:- move(D,P,t), blocked(D-1,P,t).
:- moved(D,t), on(D,P,t-1), blocked(D,P,t).

on(D,P,t) :- on(D,P,t-1), not moved(D,t).
on(D,P,t) :- move(D,P,t).
:- not 1 \{ on(D,P,t) : peg(P) \} 1, disk(D).
\end{semiverbatim}
\end{frame}

% ------------------------------------------------------------
\begin{frame}[fragile]{Towers of Hanoi Encoding}
\begin{semiverbatim}
{\bf\#program} check(t).
{\bf\#external} query(t).

:- goal_on(D,P), not on(D,P,t), query(t).
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Incremental Solving (\only<1>{ASP}\only<2>{\texttt{tohCtrl.lp}})}
\small
  \begin{semiverbatim}
{\bf{}#script} (python)

{\bf{}from} clingo {\bf{}import} SolveResult, Fun

{\bf{}def} main(prg):
    ret, parts, step = SolveResult.UNSAT, [], 1
    parts.append(("base", []))
    {\bf{}while} ret == SolveResult.UNSAT:
        parts.append(("step", [step]))
        parts.append(("check", [step]))
        prg.ground(parts)
        prg.release_external(Fun("query", [step-1]))
        prg.assign_external(Fun("query", [step]), {\bf{}True})
        ret, parts, step = prg.solve(), [], step+1

{\bf{}#end}.
  \end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Incremental Solving}
\scriptsize
\begin{semiverbatim}
\$ clingo toh.lp tohCtrl.lp \pause
clingo version 4.5.0
Reading from toh.lp ...
Solving...
Solving...
[...]
Solving...
Answer: 1
move(7,a,1)  move(6,b,2)  move(7,b,3)  move(5,a,4)  move(7,c,5)  move(6,a,6)  \\
move(7,a,7)  move(4,b,8)  move(7,b,9)  move(6,c,10) move(7,c,11) move(5,b,12) \\
move(1,c,13) move(7,a,14) move(6,b,15) move(7,b,16) move(3,a,17) move(7,c,18) \\
move(6,a,19) move(7,a,20) move(5,c,21) move(7,b,22) move(6,c,23) move(7,c,24) \\
move(4,a,25) move(7,a,26) move(6,b,27) move(7,b,28) move(5,a,29) move(7,c,30) \\
move(6,a,31) move(7,a,32) move(2,c,33) move(7,c,34) move(6,b,35) move(7,b,36) \\
move(5,c,37) move(7,a,38) move(6,c,39) move(7,c,40)
SATISFIABLE

Models       : 1+
Calls        : 40
Time         : 0.312s (Solving: 0.22s 1st Model: 0.01s Unsat: 0.21s)
CPU Time     : 0.300s
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Incremental Solving (\only<1>{Python}\only<2->{\texttt{tohCtrl.py}})}
  \small
  \begin{semiverbatim}
{\bf{}from} sys {\bf{}import} stdout
{\bf{}from} clingo {\bf{}import} SolveResult, Fun, Control

\alert<3>{prg = Control()}
\alert<3>{prg.load("toh.lp")}

ret, parts, step = SolveResult.UNSAT, [], 1
parts.append(("base", []))
{\bf{}while} ret == SolveResult.UNSAT:
    parts.append(("step", [step]))
    parts.append(("check", [step]))
    prg.ground(parts)
    prg.release_external(Fun("query", [step-1]))
    prg.assign_external(Fun("query", [step]), {\bf{}True})
    \alert<4,5>{f = {\bf{}lambda} m: stdout.write(str(m))}
    ret, parts, step = prg.solve(\alert<5>{on_model=f}), [], step+1
  \end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\begin{frame}[fragile]{Incremental Solving (Python)}
\scriptsize
\begin{semiverbatim}
\$ python tohCtrl.py \pause
move(7,c,40) move(7,a,20) move(7,c,18) move(6,a,31) move(6,b,15) move(7,b,36) \\
move(7,c,24) move(7,c,11) move(3,a,17) move(6,a,19) move(7,b,3)  move(7,c,5)  \\
move(7,a,1)  move(6,b,35) move(6,c,10) move(6,a,6)  move(6,b,2)  move(7,b,9)  \\
move(7,a,7)  move(4,b,8)  move(7,a,38) move(7,b,16) move(5,a,29) move(7,b,22) \\
move(6,c,39) move(6,c,23) move(5,b,12) move(4,a,25) move(1,c,13) move(5,a,4)  \\
move(7,a,14) move(7,a,26) move(6,b,27) move(7,a,32) move(7,b,28) move(7,c,30) \\
move(2,c,33) move(5,c,21) move(7,c,34) move(5,c,37)
\end{semiverbatim}
\end{frame}
% ------------------------------------------------------------
\section{Boardgaming}
% ------------------------------------------------------------
\input{msolving/robots}
% ------------------------------------------------------------
% \section{Interaction}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "asp"
%%% End:
